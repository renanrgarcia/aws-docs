# S3 Encryption

- You can encrypt objects in S3 buckets using one of 4 methods
- **Server-Side Encryption (SSE)**
  - `Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)` – Enabled by Default
    - Encrypts S3 objects using keys handled, managed, and owned by AWS
  - `Server-Side Encryption with KMS Keys stored in AWS KMS (SSE-KMS)`
    - Leverage AWS Key Management Service (AWS KMS) to manage encryption keys
  - `Server-Side Encryption with Customer-Provided Keys (SSE-C)`
    - When you want to manage your own encryption keys
- **Client-Side Encryption**
- It’s important to understand which ones are for which situation for the exam

## Server-Side Encryption with Amazon S3-Managed Keys (SSE-S3)

- Encryption using keys handled, managed, and owned by AWS
- Object is encrypted server-side
- Encryption type is AES-256
- Must set header "x-amz-server-side-encryption": "AES256"
- Enabled by default for new buckets & new objects
- Flow:
  - User =(HTTPS + Header)> upload =(AES-256 encryption/decryption - Object + S3 Owned Key)> S3

## Server-Side Encryption with KMS Keys stored in AWS KMS (SSE-KMS)

- Encryption using keys handled and managed by AWS KMS (Key Management Service)
- KMS advantages: user control + audit key usage using CloudTrail
  - CloudTrail logs everything that happens on AWS, including KMS key usage
- Object is encrypted server side
- Must set header "x-amz-server-side-encryption": "aws:kms"
- Flow:
  - User =(HTTPS + Header)> upload =(AES-256 encryption/decryption - Object + KMS Key)> S3

### SSE-KMS Limitation

- If you use SSE-KMS, you may be impacted by the KMS limits
- When you upload, it calls the GenerateDataKey KMS API
- When you download, it calls the Decrypt KMS API
- Count towards the KMS quota per second (5500, 10000, 30000 req/s based on region)
- You can request a quota increase using the Service Quotas Console
- Flow:
  - User =(HTTPS + Header)> upload =(AES-256 encryption/decryption - Object + KMS Key - GenerateDataKey API Call)> S3
  - User =(HTTPS + Header)> download =(AES-256 encryption/decryption - Object + KMS Key - Decrypt API Call)> S3

## Server-Side Encryption with Customer-Provided Keys (SSE-C)

- Server-Side Encryption using keys fully managed by the customer outside of AWS
- Amazon S3 does NOT store the encryption key you provide
- HTTPS must be used
- Encryption key must provided in HTTP headers, for every HTTP request made
- Only possible to set using the AWS CLI or SDKs, not possible using the AWS Management Console
- Flow:
  - User =(HTTPS Only + Header(Customer Key))> upload =(AES-256 encryption/decryption - Object + Client-provided Key)> S3
  - User =(HTTPS Only + Header(Customer Key))> download =(AES-256 encryption/decryption - Object + Client-provided Key)> S3

## Client-Side Encryption

- Use client libraries such as Amazon S3 Client-Side Encryption Library
- Clients must encrypt data themselves before sending to Amazon S3
- Clients must decrypt data themselves when retrieving from Amazon S3
- Customer fully manages the keys and encryption cycle
- Flow:
  - File + Client-side Key =(File Encryption)> File (Encrypted) =upload (HTTP(S))> S3

## Encryption in transit (SSL/TLS)

- Encryption in flight is also called SSL/TLS
- Amazon S3 exposes two endpoints:
  - HTTP Endpoint – non encrypted
  - HTTPS Endpoint – encryption in flight
- HTTPS is recommended
- HTTPS is mandatory for SSE-C
- Most clients would use the HTTPS endpoint by default

## Force Encryption in Transit aws:SecureTransport

- You can enforce the use of HTTPS for all requests to your S3 bucket by enabling the `aws:SecureTransport` condition in your bucket policy.
- This ensures that all data in transit is encrypted.
- If a request is made using HTTP, it will be denied.
- Flow:
  - User =(HTTP)> upload =(Denied - Policy)> S3
  - User =(HTTPS)> upload =(Allowed)> S3
- Example bucket policy:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Deny",
      "Principal": "*",
      "Action": "s3:*",
      "Resource": "arn:aws:s3:::your-bucket-name/*",
      // Deny if not using HTTPS
      "Condition": {
        "Bool": {
          "aws:SecureTransport": "false"
        }
      }
    }
  ]
}
```

## DSSE-KMS (Double-Sided Server-Side Encryption with KMS)

- You can combine S3 Bucket Policies with SSE-KMS to enforce encryption at rest and in transit
- Example bucket policy to enforce both SSE-KMS and HTTPS:

```json
{
  "Version": "2012-10-17",
  "Statement": [
    {
      "Effect": "Deny",
      "Principal": "*",
      "Action": "s3:PutObject",
      "Resource": "arn:aws:s3:::your-bucket-name/*",
      // Deny if not using HTTPS or not using SSE-KMS
      "Condition": {
        "Bool": {
          "aws:SecureTransport": "false"
        },
        "StringNotEquals": {
          "s3:x-amz-server-side-encryption": "aws:kms"
        }
      }
    }
  ]
}
```

- Flow:
  - User =(HTTP + No SSE-KMS)> upload =(Denied - Policy)> S3
  - User =(HTTP + SSE-KMS)> upload =(Denied - Policy)> S3
  - User =(HTTPS + No SSE-KMS)> upload =(Denied - Policy)> S3
  - User =(HTTPS + SSE-KMS)> upload =(Allowed)> S3
